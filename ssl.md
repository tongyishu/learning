原文链接（https://www.itnetworkeng.org/tls-1-2-handshake/）

1.1    TLS/SSL历史记录
安全套接字层（SSL）协议最初是由Netscape开发的，目的是保护共享网络（互联网）上的Web事务。后来SSL被标准化并重命名为传输层安全（TLS）。如今SSL版本（SSLv2和SSLv3）已被弃用，它们被认为是不安全的。此外不建议使用旧版本的TLS（TLS1.0、TLS1.1），推荐使用TLS1.2和TLS1.3。值得注意的是， “SSL”被用作描述SSLv3和TLS版本的通用术语。

 

1.2    SSL记录协议
由于安全功能是建立在数据本身上的，SSL协议应在发送者的应用层之后运行，在接收者的应用层之前运行。这个额外的层称为SSL记录层。

SSL记录层的任务是实现TLS、隐私和数据完整性的目标。换句话说，它对来自应用程序层的数据进行加密和签名。



在将消息向下传递到TCP层进行传输之前，SSL记录子层：

-          将消息分段为可管理的块

-          压缩片段（可选）

-          在压缩片段上应用MAC（Message Authentication Code）

-          加密压缩分片（包括MAC）并传输结果。

 

请注意，MAC是在加密之前计算的。当接收端的记录层得到此结果时，它将解密接收到的结果，验证MAC，并解压缩。

如果发送对等体的SSL记录子层将消息分段，接收对等体的记录子层也将重组它们。然后将处理后的消息下发给高层。

要使TLS记录层工作，需要两条信息：

- 两个连接端将使用的压缩算法、加密算法和MAC算法。

- 两端使用的MAC算法的密钥和加密算法的密钥。

 

1.2.1    消息分段（Fragmentation）
RFC规定SSL记录负载的大小不得超过16k字节。正如我们将在握手过程中看到的那样，服务器很可能发送大尺寸的消息。在这种情况下，记录层将消息分成小片段，每个片段最大16k字节。

 

1.2.2    压缩和解压缩（Compression and Decompression）
默认情况下，SSL压缩是关闭的，因为它容易受到攻击。

 

1.2.3    负载保护（Payload Protection）
要使SSL记录层执行其安全功能，它需要知道它将使用哪种哈希算法、加密算法和密钥来保护数据。

这些算法和密钥是在客户端和服务器之间协商的。另一种称为握手协议（Handshake）的协议用于允许对等体就SSL记录层的安全参数达成一致。



由于必须首先获取和协商这些算法和密钥，以告知SSL记录协议有关它们的信息，因此握手协议应在SSL记录层之前运行。

这解释了为什么TLS是分层协议。TLS协议由几个子协议组成，每个子协议负责特定的任务。

现在，假设一方不支持另一方提供的算法。此方将如何通知另一方这种情况？这是另一个协议的责任，称为警报协议（Alert）。



需要的另一个协议是ChangeCipherSpec。ChangeCipherSpec消息由一方发送，通知另一方它已经准备好，并使用协商的密钥和算法来保护后续数据。



最后，通过TLS安全地交换数据。



 

1.3    SSL报文结构
SSL下发给TCP的PDU称为记录。记录由报文头和有效负载组成，如下所示：



1.3.1    SSL记录类型（SSL Record Type）
如前所述，SSL依赖于不同的协议。对于每个协议，通信各方交换负载中的特定信息，以实现其在SSL操作中的作用。每个协议的净荷内容与其他协议的净荷内容不同。例如，ChangeCipherSpec协议的数据包负载的内容仅为0或1值，如下图所示：



而应用程序数据协议的数据包负载的内容是客户端和服务器之间在受到保护后的实际数据，如下图所示：



因此为了使接收端按预期解释有效载荷，它需要额外的信息来指导它区分另一端发送数据包的协议。为了实现这一目标，在净荷字段之前应该存在一个头字段。此头字段称为SSL记录类型。由于SSL依赖于四种协议，因此有四种SSL记录类型。下表显示了这些记录类型的值：



通过遵循这些值，接收端将知道它接收的记录类型，以便它能够处理和正确解释它。

 

1.3.2    SSL版本
决定两端之间将使用的SSL/TLS版本是可以协商的。客户端在与服务器建立SSL连接之前，必须就可协商的版本达成一致，因此客户端必须指定它使用的SSL版本，以便服务器能够正确解释数据包，直到它们在整个连接过程中将使用的版本达成一致。此字段的用法之一，也与向后兼容性有关。

 

1.3.3    握手协议（Handshake）
握手协议允许对等体商定SSL记录协议所需的安全算法和参数，以保护会话期间客户端和服务器之间交换的实际数据。换句话说，握手协议允许对等体：

1 协商SSL版本和密码套件

2 相互认证（客户端认证是可选的），即证书认证

3 交换生成主密钥所需的密钥/信息。

4 派生共享密钥（用于加密和MAC）

 

1.3.4    Client Hello
对等体之间交换的第一条消息是ClientHello消息，如下图所示：



 

ClientHello消息的结构如下图所示：



请注意，握手协议的记录类型的值为22。当握手在对等体之间交换各种消息类型时，如上图所示，这些消息也需要被识别。区分它们的字段称为“type”。



ClientHello消息被赋予“Type”值“1”。

 

VERSION

在ClientHello消息中，客户端通过告诉服务器它可以支持的最高SSL版本来建议SSL/TLS版本。例如，如果客户端提出了TLS1.2的版本，这意味着它支持TLS1.1、TLS1.0和任何SSL版本。接收后，服务器选择它愿意使用的版本来保护与客户端的通信。回到上一个示例，服务器可以协商除TLS1.3以外的任何版本，因为它不是由客户端提出的。

但是，如果客户端建议的版本不受服务器支持，连接将失败，服务器将通过Alert协议消息通知客户端原因。

每个版本的值如下表所示：



 

CIPHER SUITES

客户建议其支持的密码套件：



 

密码套件列表示例如下，使用openssl ciphers -v命令可以查看所有的加密套件。

DHE-RSA-AES256-SHA256 TLSv1.2 Kx=DH Au=RSA Enc=AES(256) Mac=SHA256

-          DHE-RSA-AES256-SHA256 加密套件名称

-          TLSv1.2协议版本

-          Kx密钥交换算法

-          Au签名算法

-          Enc批量加密算法

-          Mac消息摘要算法

 

在ClientHello消息中从客户端传递到服务器的密码套件列表包含客户端支持的加密算法的组合，按客户端的首选项（首选选择优先）的顺序排列。

 

COMPRESSION METHODS

客户端建议其支持的压缩方法：



在实践中，压缩方法为“NULL”，即不需要压缩。

 

SESSION ID

客户端告诉服务器它是愿意建立新会话还是恢复旧会话：



在握手协议中，两个对等体协商安全算法和参数。这种谈判需要昂贵的处理。引入“TLS会话”机制，以帮助避免每次客户端尝试与同一服务器建立连接时重复这种密集处理。

每当客户端和服务器之间建立连接时，会话ID就会与此连接关联。此会话ID定义客户端和服务器商定的安全算法和参数。客户端和服务器都缓存此会话ID以及与此会话关联的商定安全算法和参数。

当客户端与服务器建立新连接时，它将ClientHello消息中的“会话ID”字段保留为空。当服务器收到此类消息时，它将理解客户端愿意开始新的协商并进行完整的握手消息交换。请注意，会话ID是服务器生成的随机数，它在ServerHello消息中发送到客户端。

稍后客户端很可能会与此服务器建立另一个连接。在这种情况下，客户端将使用在较早连接中生成的会话ID填充“会话ID”。当服务器收到这样的消息时，它将理解客户端愿意重用他们在上一次连接期间商定的安全算法和参数。在这种情况下，客户端和服务器将跳过剩余的握手消息交换（ChangeCipherSpec完成消息除外）

SESSION ID LENGTH



请注意，对于声称支持TLS 1.2的客户端，session_id_length的值必须为零。因为会话ID是随机生成的，其长度是可变的。

 

RANDOM NUMBER



客户端生成一个随机数，并与服务器交换。这个随机数用于master_secret推导。

 

EXTENSIONS



扩展项此处不展开描述。

 

1.3.5    Server Hello


当服务器能够找到支持的SSL版本和可接受的密码套件时，服务器将发送此消息以响应ClientHello消息。如果它找不到这样的匹配项，它将以握手失败警报响应。此消息的结构字段与ClientHello消息相同：



ServerHello消息被赋予“Type”值“2”。

 

VERSION

在此字段中，服务器告诉客户端将在整个连接中使用的SSL版本。



但是，如果客户端建议的版本不受服务器支持，连接将失败，服务器将通过警报消息通知客户端原因。

 

RANDOM NUMBER



服务器生成一个随机数，并与客户端交换。这个随机数用于导出主密钥，我们稍后将看到。

 

SESSION ID



这是与此连接对应的会话的标识。如果ClientHello消息中的“SESSION ID”字段非空，服务器将在其会话缓存中查找匹配项。

请注意，会话ID将保留在服务器或客户端上，直到它因老化而被删除、服务器重新启动或客户端（如Web浏览器）关闭。也可以删除它，因为在与会话关联的连接上遇到了致命错误。

如果找到匹配项，并且服务器愿意使用先前商定的安全算法和参数建立新连接，服务器将以与客户端提供的相同的值响应。这表示会话已恢复，并规定双方必须直接进入已完成消息。

如果找不到会话ID匹配，服务器将生成标识新会话的新会话ID,TLS客户端和服务器将执行完整握手。

服务器可能会返回一个空的“SESSION ID”字段，以指示会话将不会被缓存，因此无法恢复。

 

CIPHER SUITS



服务器向客户端返回单个密码套件。这是服务器从客户端在ClientHello消息中建议的列表中选择的密码套件。该密码套件将在整个连接中使用。对于恢复的会话，此字段是正在恢复的会话中使用的密码套件。如果没有提供可接受的选项，服务器将返回握手失败警报并关闭连接。如果列表包含服务器不识别、不支持或不希望使用的密码套件，服务器将忽略这些密码套件，并照常处理其余的密码套件。

 

COMPRESSION METHODS



在实践中，压缩方法为“NULL”，即不需要压缩。

 

EXTENSIONS



扩展项此处不展开描述。

 

1.3.6    Server Certificate
此消息紧随ServerHello消息之后。



服务器发送此消息，以便客户端可以验证服务器证书并对其进行身份验证。服务器证书握手消息的类型为11：



此消息将服务器的证书链传递给客户端，服务器首先发送自己的身份证书：



下一个证书是颁发服务器身份证书的CA证书：



后面的证书是直接证明验证前面证书的证书，直到到达根证书：



 

1.3.7    Certificate Request
只有当服务器在握手过程中需要客户端身份验证时，服务器才会发送此消息。匿名服务器不使用它，如浏览公共互联网网站，但很可能在VPN和EAP-TLS中实现。



证书请求握手消息的类型为13。

 

CLIENT CERTIFICATE TYPES

服务器不仅要求客户端出示其证书，而且还指定可接受的密钥类型和CA。客户端可能提供的证书类型列表：

-          rsa_sign 包含RSA密钥的证书

-          dss_sign包含DSA密钥的证书

-          rsa_fixed_dh 用RSA签名并包含静态DH密钥的证书

-          dss_fixed_dh 用DSA签名并包含静态DH密钥的证书

 

SUPPORTED SIGNATURE ALGORITHMS

客户端提供的任何证书都必须使用在支持的签名算法中找到的哈希/签名算法对进行签名。

 

证书请求消息中支持的哈希算法及其对应的值：

none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5), sha512(6)

 

证书请求消息中支持的签名算法及其对应的值：

anonymous(0), rsa(1), dsa(2), ecdsa(3)

 

CERTIFICATE AUTHORITIES

在此字段中，服务器列出它接受的CA，无论是根CA还是从属CA。如果CA列表为空，则客户端可以发送相应ClientCertificateType的任何证书。

由于历史原因，某些客户端证书类型的名称包括用于签名证书的算法。例如，在TLS的早期版本中，rsa_fixed_dh是指用RSA签名并包含静态DH密钥的证书。在TLS 1.2中，此功能已被supported_signature_algorithms取代，证书类型不再限制用于签名证书的算法。例如，如果服务器发送dss_fixed_dh证书类型和{{sha1,dsa},{sha1,rsa}}签名类型，则客户端可能会回复包含静态DH密钥的证书，并使用RSA-SHA1签名。

 

1.3.8    Server Hello Done


指示服务器在此阶段没有更多消息要发送。发送此消息后，服务器将等待客户端响应。

在收到ServerHelloDone消息后，客户端应验证服务器是否提供了有效的证书（如果需要），并检查服务器Hello参数是否可接受。

 

1.3.9    Client Certificate


此消息由客户端发送，以响应来自服务器的证书请求消息，包含客户端的证书或证书链。

如果没有合适的证书可用，客户端发送不包含证书的证书消息。如果客户端没有发送任何证书，服务器可以自行决定在没有客户端身份验证的情况下继续握手，或者以致命的握手失败警报响应。此外，如果证书链的某些方面是不可接受的（例如，它不是由已知的、受信任的CA签名的），服务器可以自行决定继续握手（考虑到客户端未经身份验证）或发送致命警报。

 

1.3.10 ClientKeyExchange Message


ServerKeyExchange握手消息的类型为16。

Key Exchange

在TLS中，数据加密和MAC密钥生成遵循以下几个步骤：

1 每一方都与另一方交换其公钥（除非密钥交换方法为RSA，如后面所述）。

2 基于上述交换，客户端和服务器派生相同的共享密钥。根据RFC，此密钥称为pre_master_secret。

3 此密钥使用ClientHello和ServerHello消息中发送的随机值进行哈希，以生成更安全的密钥。根据RFC，此密钥称为master_secret。

4 最后，使用此master_secret，为每个连接获得唯一的数据加密密钥和MAC密钥。

 

对于所有密钥交换方法，使用相同的算法将pre_master_secret转换为master_Secret：

master_secret = PRF(pre_master_secret, “master secret”, ClientHello.random + ServerHello.random);

然而，传递密钥交换信息的消息因方法而异。SSL支持的密钥交换方法有：

-          RSA

-          FIXED DIFFIE-HELLMAN

-          EPHEMERAL DIFFIE-HELLMAN (DHE)

-          EPHEMERAL DIFFIE-HELLMAN WITH ELLIPTIC CURVES(ECDHE)

 

 

1.3.11 CertificateVerify


只有在实现了客户端身份验证并且客户端证书具有签名能力（即除包含固定DH密钥的证书外的所有证书）时，客户端才会发送此消息。此消息的用途是让服务器确保到目前为止的TLS握手消息是从预期的客户端发送的，而不是欺骗的客户端发送的。此消息包含到目前为止所有握手消息的哈希，从客户端hello开始，直到（但不包括）由客户端私钥签名的此消息。

如果另一个人冒充实际客户，他就不会成功，因为只有实际客户拥有他证书的私钥。

签名中使用的哈希和签名算法必须是证书请求消息的supported_signature_algorithms字段中存在的哈希和签名算法之一。

1.3.12 ChangeCipherSpec


ChangeCipherSpec消息由客户端和服务器发送，通知接收方后续记录将受到协商的算法和密钥的保护。ChangeCipherSpec字段的值为“1”。



 

1.3.13 ClientFinished and ServerFinished


FINISH消息用于验证密钥交换和身份验证过程是否成功。

FINISH消息是第一个受刚刚协商的算法和密钥保护的消息。已完成消息的接收人验证内容是否正确。一旦一方发送了其完成消息，并从其对等方接收和验证了完成消息，它就可以开始通过连接发送和接收应用程序数据。

客户端发送的名为“ClientFinished”的已完成消息，SSL记录类型为20。服务器发送的已完成消息称为“ServerFinished”，SSL记录类型为22。

此消息包含到目前为止所有握手消息的哈希，不包括握手消息本身，由发送人的密钥加密和签名。
